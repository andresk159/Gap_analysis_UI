#
# This is the server logic of a Shiny web application. You can run the 
# application by clicking 'Run App' above.
#
# Find out more about building applications with Shiny here:
# 
#    http://shiny.rstudio.com/
#

library(shiny)
# setting global variables
g <- gc(reset = T); rm(list = ls()); options(warn = -1); options(scipen = 999)
urls <- read.csv("www/downloadable_files.csv", stringsAsFactors = F)
shp <- shapefile("www/world_shape_simplified/all_countries_simplified.shp")
scrDir <- "www/scripts"
if(Sys.getenv('SHINY_PORT') == "") options(shiny.maxRequestSize=30*1024^2)
options(scipen = 999)
update_scripts <- FALSE
source("www/helpers.R", local = TRUE)


# Define server logic required to draw a histogram
server <- function(input, output,session) {

  output$messageMenu <- renderMenu({
    
    crop    <- ifelse(nchar(input$set.crop.name) == 0, "Not specified yet", input$set.crop.name)
    occName <- ifelse(nchar(input$set.level.name) == 0, "Not specified yet", input$set.level.name)
    region  <- ifelse(nchar(input$mask_name) == 0, "Not specified yet", input$mask_name)

    msgs <- list(messageItem(from = "Crop Name" , message = crop,    icon = icon("fas fa-seedling")),
                 messageItem(from = "Group Name", message = occName, icon = icon("fas fa-sitemap")),
                 messageItem(from = "Region"    , message = region,  icon = icon("fas fa-map-pin")) )
   
    # This is equivalent to calling:
    #   dropdownMenu(type="messages", msgs[[1]], msgs[[2]], ...)
    dropdownMenu(type = "messages", .list = msgs)
    
  })
  
  rvs <- reactiveValues(baseDir = NULL)
  polylines <- reactiveValues(geom = data)
  clicklist <- reactiveValues(ids = vector(), names = vector())

  #create button to select container folder to create dirs and download data
  shinyDirChoose(input , id =  "select_path_btn", updateFreq = 0, session = session,
                 defaultPath = "", roots =  c('Documents' = Sys.getenv("HOME"), 'Local Disk' = Sys.getenv("HOMEDRIVE") ))
  
  
  #boton para seleccionar los directorios
  observeEvent(input$select_path_btn, {
    text_path <- parseDirPath(roots =  c('Documents' = Sys.getenv("HOME"), 'Local Disk' = Sys.getenv("HOMEDRIVE") ), input$select_path_btn)
    rvs$baseDir <- text_path
    .GlobalEnv$baseDir <- as.character(text_path)
    updateTextInput(session, "selected.root.folder", 
                    label = "Dir path chosen",
                    value = as.character(text_path)
    )
    
  })
 

  #boton para crear los directorios y descargar los scripts desde github
  observeEvent(input$create_dirs,{
   print(rvs$baseDir)
    if(!is.null(rvs$baseDir)){
      
      crop            <- input$set.crop.name
      occName         <- input$set.level.name
      .GlobalEnv$crop <- input$set.crop.name
      .GlobalEnv$occName <- input$set.level.name
      
      if(nchar(crop) > 0 & nchar(occName) > 0 ){
        print(baseDir)
        global_data_dir<- paste0(baseDir, "/global_data")
        worldDir       <- paste0(global_data_dir, "/environmental_rasters");if(!file.exists(worldDir)){dir.create(worldDir, recursive = TRUE)}
        mapspamDir     <- paste0(global_data_dir, "/MapSpam_rasters");if(!file.exists(mapspamDir)){dir.create(mapspamDir, recursive = TRUE)}
        aux_dir        <- paste0(global_data_dir, "/auxiliar_rasters");if(!file.exists(aux_dir)){dir.create(aux_dir, recursive = TRUE)}
        res_dir        <- paste0(baseDir, "/results/", crop);if(!file.exists(res_dir)){dir.create(res_dir, recursive = TRUE)}
        
        sendSweetAlert(
          session = session,
          title = "Success !!",
          text = "The main directories were successfully created.",
          type = "success"
        )
        
        
        updateButton(session, "create_dirs",label = "Dirs created",style = "success")
      }else{   
        sendSweetAlert(
          session = session,
          title = "Error !!",
          text = "Please write a valid Crop or Race name.",
          type = "error"
        )
        #Sys.sleep(3)
        #stopApp()
        #session$close() 
      }
        
      #update scripts
      #input$update_scripts == "Yes"
      if(FALSE){
        #descargar scripts desde github
        lists <- c( "00_config/config.R",
                    "00_config/config_crop.R",
                    "00_config/pre_config.R",
                    "01_classification/.Rhistory",
                    "01_classification/classification_function.R",
                    "01_classification/classification_function_new_models.R",
                    "01_classification/create_occ_shp.R",
                    "01_classification/crop_raster.R",
                    "01_classification/prepare_input_data.R",
                    "02_sdm_modeling/.DS_Store",
                    "02_sdm_modeling/.Rhistory",
                    "02_sdm_modeling/background_points.R",
                    "02_sdm_modeling/calibration_function.R",
                    "02_sdm_modeling/null_model.R",
                    "02_sdm_modeling/sdm_maxnet_approach_function.R",
                    "02_sdm_modeling/tuning_maxNet.R",
                    "03_gap_methods/.DS_Store",
                    "03_gap_methods/.Rhistory",
                    "03_gap_methods/combine_score.R",
                    "03_gap_methods/cost_distance_function.R",
                    "03_gap_methods/create_buffers.R",
                    "03_gap_methods/create_png_maps.R",
                    "03_gap_methods/delaunay.R",
                    "03_gap_methods/delaunay_geo_score.R",
                    "03_gap_methods/ecogeo_cluster.R",
                    "03_gap_methods/env_distance.R",
                    "03_gap_methods/gap_maps.R",
                    "03_gap_methods/gaps_validation.R",
                    "03_gap_methods/generate_report.R",
                    "03_gap_methods/kernel_function.R",
                    "03_gap_methods/mask_delaunay.R",
                    "03_gap_methods/rasterbuffer_to_polygons.R",
                    "03_gap_methods/summary_function.R",
                    "03_gap_methods/validation_function.R",
                    "03_gap_methods/validation_helpers.R",
                    "03_gap_methods/validation_helpers_original.R")
        for(i in 1:length(lists)){
          url <- paste0("https://raw.githubusercontent.com/andresk159/Gap_analysis_UI/master/www/scripts", lists[i])
          download.file(url,destfile = paste("www", "scripts", lists[i], sep = .Platform$file.sep))
        }
        sendSweetAlert(
          session = session,
          title = "Success !!",
          text = "the Most updated scripts were downloaded successfully.",
          type = "success"
        )
      }
 

    }else{
      sendSweetAlert(
        session = session,
        title = "Error !!",
        text = "Please, select a valid Dir path from the Choose Dir buttom.",
        type = "error"
      )
    }
 
    
  })#end boton para crear directorios y descargar scripts
 
  
  output$map_selector <- renderLeaflet({
    leaflet("map_selector") %>% 
      setView(lat= 0, lng = 0, zoom = 1) %>% 
      addTiles(options = providerTileOptions(noWrap = TRUE) )%>% 
      addPolygons(data= shp,stroke = T,color = "#4682B4", weight = 1, smoothFactor = 0.2,  #adicionar el archivo .shp al mapa y hacer que brillen cuadno son seleccionados
                  label = ~as.character(shp@data$ISO3),
                  layerId = shp@data$ISO3,
                  opacity = 0.5, fillOpacity = 0.5,
                  fillColor = "#D6DEE6",
                  highlightOptions = highlightOptions(color = "#696262", weight = 2,
                                                      bringToFront = F) )
    
  })
  
  

  observeEvent(c(input$map_selector_shape_click, input$area_selector),{
    proxy <- leafletProxy("map_selector")
    
    cont <- as.numeric(input$area_selector)
    if(cont == 0 | cont == 8){
      shp_custm <<- shp[shp@data$REGION != cont, ]
      proxy %>% 
        clearShapes() %>% 
        addPolygons(data= shp_custm, stroke = T,color = "#2690EF", weight = 1, smoothFactor = 0.2,  #adicionar el archivo .shp al mapa y hacer que brillen cuadno son seleccionados
                    opacity = 0.5, fillOpacity = 0.5,
                    layerId = shp_custm@data$ISO3,
                    fillColor = "#D6DEE6",
                    highlightOptions = highlightOptions(color = "#696262", weight = 2,
                                                        bringToFront = TRUE) )
    }else{
      shp_custm <<- shp[shp@data$REGION == cont, ]
      proxy %>% 
        clearShapes() %>% 
        addPolygons(data= shp_custm, stroke = T,color = "#2690EF", weight = 1, smoothFactor = 0.2,  #adicionar el archivo .shp al mapa y hacer que brillen cuadno son seleccionados
                    opacity = 0.5, fillOpacity = 0.5,
                    layerId = shp_custm@data$ISO3,
                    fillColor = "#D6DEE6",
                    highlightOptions = highlightOptions(color = "#696262", weight = 2,
                                                        bringToFront = TRUE) )
    }
    
    
    
    if(as.numeric(input$area_selector) == 8){
      
      click <- input$map_selector_shape_click
      # Store click IDS in reactiveValue
      clicklist$ids <- c(clicklist$ids, click$id)
  
      if(any(duplicated(clicklist$ids))){
        
        val <- clicklist$ids[duplicated(clicklist$ids)]
        clicklist$ids <- clicklist$ids[!clicklist$ids %in% val]
      }
      
      shp_custom <- shp[shp@data$ISO3 %in% clicklist$ids,]
      clicklist$names <- shp_custom@data$NAME
      print(clicklist$names)
      proxy %>% 
        addPolygons( data= shp_custom,
                     layerId = shp_custom@data$ISO3,
                     color = "#444444", weight = 0.5, smoothFactor = 0.5,
                     opacity = 1.0, fillOpacity = 0.5,
                     fillColor ="yellow" )
    }
    
  }) 
 
observe({ 
    if(as.numeric(input$area_selector) == 8){
      updateCheckboxGroupInput(session, inputId = "chk_bx_gr", label = "Countries selected:", choices = clicklist$names, selected = clicklist$names)
   
    }
  })

 observeEvent(input$create_mask,{
   
      if(nchar(as.character(input$mask_name)) != 0){
     ## poner bussy indicator
     msk <<- paste(baseDir, "input_data", "mask",paste0("mask_" , as.character(input$mask_name), ".tif") , sep = .Platform$file.sep)
     
     withBusyIndicatorServer("create_mask", {
       
     raster("www/masks/mask_world.tif") %>% 
       raster::crop(., y = extent(shp_custm)) %>%
       raster::mask(., shp_custm) %>%
       writeRaster(., msk, overwrite = T)
     
       }) 
     updateButton(session, "create_mask",label = "Mask created",style = "success")
     region <<- input$mask_name
     
   }else{
     showModal(modalDialog(
       title = "Warning message:",
       h4("Please write a valid name for the mask file."),footer = NULL,easyClose = TRUE ))
     
   }
   
   
 })
 
 
#####                                    #####
##### DESCARGA DE INPUT RASTER Y DEMAS  #####
#####                                  #####
 
 observeEvent(input$download_data, {
   lg <- ifelse(input$download_spam == 2, TRUE, FALSE)
   withBusyIndicatorServer("download_data", {
   if(lg){
     urls %>% dplyr::filter(., screen_name == as.character(input$slct_crop_name)) %>% dplyr::select(., name, download_url)  %>%  
       apply(., 1,function(i){
         download.file(as.character(i[2]), destfile = paste(baseDir, "input_data", "by_crop", .GlobalEnv$crop, "raster","world",  as.character(i[1]), sep  = .Platform$file.sep), mode = "wb")
       } )
   }
   
   if(as.logical(input$download_clim) ){
     
     urls %>% dplyr::filter(., screen_name == "generic_rasters") %>% dplyr::select(., name, download_url)  %>%  
       apply(., 1,function(i){
         download.file(as.character(i[2]), destfile = paste(baseDir, "input_data", "generic_rasters","world",  as.character(i[1]), sep  = .Platform$file.sep), mode = "wb")
       } )
     #download friction surface
     if(!file.exists(paste(baseDir, "input_data", "auxiliar_rasters", "friction_surface.tif", sep = .Platform$file.sep))){
       download.file("https://drive.google.com/uc?export=download&id=1ssBlQBtaVZw-c-ALS2iPlztYORughq6h", destfile = paste(baseDir, "input_data", "auxiliar_rasters", "friction_surface.tif", sep = .Platform$file.sep), mode = "wb")
     }
     #download ecosregions raster
     if(!file.exists(paste(baseDir, "input_data", "ecosystems", "World_ELU_2015_5km.tif", sep = .Platform$file.sep))){
       download.file("https://drive.google.com/uc?export=download&id=1pdCXTej4-92VIY9sbdaiMecZNpsopsWc", destfile = paste(baseDir, "input_data", "ecosystems", "World_ELU_2015_5km.tif", sep = .Platform$file.sep), mode = "wb")
     }
     
       
     
     
     }
   })
   updateButton(session, "download_data",label = "Files downloaded",style = "success")
 })
 
 ### crop raster after they has been download
 
 observeEvent(input$crop_rasters, {
   withBusyIndicatorServer("crop_rasters", {  
   if(file.exists(msk) & nchar(region) != 0 & nchar(level_1) != 0 & nchar(crop)  != 0 & nchar(occName) != 0){
     source(paste(srcDir, "/02_sdm_modeling/preprocessing/config.R", sep = ""), local = F)
     
   }
   crop_raster(mask   = mask,
               region = region )
   updateButton(session, "crop_rasters",label = "Rasters cropped",style = "success")
   })
   
 })
 
 
 
 #### cargar base de datos y realizar el proceso de limpieza 
 bd <- reactive({

   req(input$data_in)
   tryCatch(
     {
       df.raw <- read.csv(input$data_in$datapath, header = TRUE, sep = ",") %>% dplyr::slice(., 1:(nrow(.)*0.2))
       
       
     },
     error = function(e) {
       # return a safeError if a parsing error occurs
       stop(safeError(e))
     }
   )
   return(df.raw)
 })
 

 
  output$data_prev <- renderDataTable({
    bd()
  }, options = list(pageLength =5, scrollX = FALSE))
  
  
 ########## boton para crear la base de datos
  observeEvent(input$prepare_data, {
    
   withBusyIndicatorServer("prepare_data", {
     

    if(file.exists(msk) & nchar(region) != 0 & nchar(level_1) != 0 & nchar(crop)  != 0 & nchar(occName) != 0){
      source(paste(srcDir, "/02_sdm_modeling/preprocessing/config.R", sep = ""), local = F)
      
    }
    lgx <- ifelse(input$do_ensemble_models == "1", FALSE,  TRUE) 
    
      
    prepare_input_data(data_path = input$data_in$datapath,
                       col_number = input$col_number,
                       do.ensemble.models = lgx,
                       add.latitude = as.logical(input$add.latitude),
                       add.longitude = as.logical(input$add.longitude),
                       do.predictions = as.logical(input$do.predictions),
                       sampling_mthd = input$sampling_mthd,
                       mask = input$mask$datapath)
  
   
      updateButton(session, "prepare_data",label = "Database consolidated",style = "success")
    })
    
    bd_final <- reactive({
      if(file.exists( paste0(classResults, "/", crop, "_lvl_1_bd.csv"))){
        bd_prev <- read.csv(paste0(classResults, "/", crop, "_lvl_1_bd.csv"))
      }
      return(bd_prev)
    })
    
    output$data_out <-  renderDataTable({
     bd_final()
    }, options = list(pageLength =5, scrollX = TRUE))
    

  })
  
  
  ##### cost distance Function ####
  
  observeEvent(input$calculate_cost,{
    
    withBusyIndicatorServer("calculate_cost", { 
    create_occ_shp(file_path   = input$occ_in$datapath,
                   file_output = paste0(occDir,"/Occ.shp"),
                   validation  = FALSE)
    
    # Cost distance process according with the level of analysis
    cost_dist_function(
      outDir       = gap_outDir,
      friction     = input$friction_in$datapath,
      mask         = mask,
      occDir       = occDir,
      arcgis       = FALSE,
      code         = paste0(sp_Dir_input, "/cost_dist.py")
    )
    
    })
    updateButton(session, "calculate_cost",label = "Raster calculated",style = "success")
    
   
    output$out_1 <- renderPlot({
      shp_ctm <- shp[shp@data$NAME != "Antarctica",] %>% raster::crop(., y = extent(raster(paste0(gap_outDir,"/cost_dist.tif")) ))
      
      ggplot() +
        geom_raster(data = raster(paste0(gap_outDir,"/cost_dist.tif")) %>% as.data.frame(., xy =T) %>% dplyr::filter(., !is.na(cost_dist)), aes(x = x, y = y, fill = cost_dist)) +
        coord_equal() +
        scale_fill_continuous(type = "viridis")+ 
        geom_polygon(data=shp_ctm, aes(x=long, y=lat, group=group),fill=NA,color="black", size=0.7)+
        geom_point(data = shapefile(paste0(occDir,"/Occ.shp")) %>% as.data.frame(),mapping =  aes(x = coords.x1 , y = coords.x2, color = "red"))+
        theme_dark() +
        xlab("") +
        ylab("") 
        #theme(legend.position = "none")+
        
    
    })
    
  })
  

  #########               ########
  ######### SDM MODELLING ########
  #########               ########
  
  ## check if occ file exists
  
  output$occ_exists <- renderUI({
    tags$div(id = "occ_status", style = " 
             width: 100%;
             padding: 12px 20px;
             margin: 4px 0;
             display: inline-block;
             border: 1px solid #ccc;
             border-radius: 4px;
             box-sizing: border-box;
             background-color: #D7D7D7;",
             HTML(ifelse(file.exists(paste(classResults, paste0(crop, "_lvl_1_bd.csv"), sep = .Platform$file.sep)), 
                         paste("<p>Database  <font color = 'green'><strong> is already created</strong> </font></p>") , 
                         paste("<p>Database  <font color = 'red'><strong>  not exists</strong> </font></p>"))
    ))
    
  })
  
  
observeEvent(input$create_pseudo, {
  
  withBusyIndicatorServer("create_pseudo", { 
    
    .GlobalEnv$var_names   <- model_driver(sp_Dir      = sp_Dir,
                                           mask        = mask,
                                           occName     = occName,
                                           extension_r = ".tif",
                                           all         = F,
                                           overwrite   = T,
                                           clsModel    = "ensemble",
                                           correlation = 1,#input$cor_method,# 1. Correlation, 2. VIF, 3. PCA + VIF
                                           pa_method = "all_area"#input$pseudo_method
    )
 
    .GlobalEnv$spData <- read.csv(paste0(swdDir, "/swd_", occName, ".csv"))
    
    })
  updateButton(session, "create_pseudo",label = "File created",style = "success")
  
  
})
  
  output$map2 <- renderLeaflet({
    
    req(spData)
    
    pal <- colorFactor(c("red", "blue"), domain = spData$status)
    leaflet(data = spData ) %>% addTiles() %>% addCircles(., 
                                                          lng = ~lon, 
                                                          lat = ~lat , 
                                                          color = ~pal(status), 
                                                          fillOpacity = 1, 
                                                          radius = 10000,
                                                          stroke = F,
                                                          group =   "pse") %>%
      addLegend(color = c("red", "blue"), 
                labels = c("Pseudo-absences", "Occurrences"), 
                group = "pse", 
                position = "bottomleft")
    
  })
  
  
  
  ##### SDM MODEL : MAXENT MODEL SECIFICATIONS ###############33
  
  observe({
    req(input$feat)
    print(paste(input$feat, collapse = ""))
  })
  
}#end everything










